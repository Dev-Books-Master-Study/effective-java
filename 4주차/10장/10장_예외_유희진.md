## [아이템 73] 추상화 수준에 맞는 예외를 던지라

> 아래 계층의 예외를 예방하거나 스스로 처리할 수 없고, 그 예외를 상위 계층에 그대로 노출하기 곤란하다면 예외 번역을 사용하라. 이때 예외 연쇄를 이용하면 상위 계층에는 맥락에 어울리는 고수준 예외를 던지면서 근본 원인도 함께 알려주어 오류를 분석하기에 좋다.
> 

<aside>
✅ 고수준 모듈

- 의미 있는 단일 기능을 제공
- 상위 수준의 정책을 구현

저수준 모듈

- 고수준 모듈의 기능을 구현하기 위해 필요한 하위 기능의 실제 구현
[https://velog.io/@kshired/객체-지향-프로그래밍-입문-DIP](https://velog.io/@kshired/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9E%85%EB%AC%B8-DIP)
</aside>

- 수행하려는 일과 관련 없어 보이는 예외가 튀어나오면 당황스러울 것이다.
    - **메서드가 저수준 예외를 처리하지 않고 바깥으로 전파해버릴 때** 종종 일어나는 일이다.
    - 사실 이는 단순히 프로그래머를 당황시키는 데 그치지 않고 내부 구현 방식을 드러내어 윗 레벨 API를 오염시킨다.
    - 다음 릴리스에서 구현 방식을 바꾸면 다른 예외가 튀어나와 기존 클라이언트 프로그램을 깨지게 할 수도 있는 것이다.
- 이러한 문제를 피하려면 **상위 계층에서는 저수준 예외를 잡아 자신의 추상화 수준에 맞는 예외로 바꿔 던져야한다.**
    - 이를 예외 번역(exception translation)이라고 한다.
        
        ```java
        try {
        	...
        // 저수준 추상화를 이용
        } catch (LowerLevelException e) {
        	// 추상화 수준에 맞게 번역한다.
        	throw new HigherLevelException(...);
        }
        ```
        
- 예외를 번역할 때 저수준 예외가 디버깅에 도움이 된다면 **예외 연쇄(exception chaining)**를 사용하는 것이 좋다.
    
    ```java
    try {
    	...
    // 저수준 추상화를 이용한다.
    } catch (LowerLevelException cause) {
    	// 저수준 예외를 고수준 예외에 실어 보낸다.
    	throw new HigherLevelException(cause);
    }
    ```
    
    - **예외 연쇄란 문제의 근본 원인인 저수준 예외를 고수준 예외에 실어 보내는 방식**이다.
    - 그러면 별도의 접근자 메서드(`Throwable`의 `getCause` 메서드)를 통해 필요하면 언제든 저수준 예외를 꺼내볼 수 있다.
    - 고수준 예외의 생성자는 **예외 연쇄용으로 설계된 상위 클래스의 생성자에 이 원인을 건네주어 최종적으로 `Throwable`(`Throwable`) 생성자까지 전달되도록 한다.**
        
        ```java
        class HigherLevelException extends Exception {
        	HigherLevelException(Throwable cause) {
        		super(cause);
        	}
        }
        ```
        
- 대부분의 표준 예외는 **예외 연쇄용 생성자를 갖추고 있다.**
    - 그렇지 않은 예외라도 `Throwable`의 `initCause` 메서드를 이용해 원인을 직접 못박을 수 있다.
    - 예외 연쇄는 문제의 원인을 (`getCause` 메서드로) 프로그램에서 접근할 수 있게 해주며, 원인과 고수준 예외의 스택 추적 정보를 잘 통합해준다.
- 예외를 전파하는 것보단 예외 번역이 더 나은 방법이지만, 남용해서는 곤란한다.
    - **가능하다면 저수준 메서드가 반드시 성공하도록 하여 아래 계층에서는 예외가 발생하지 않도록 하는 것이 최선**이다.
    - 때론 **상위 계층 메서드의 매개변수 값을 아래 계층 메서드로 전달하기 전에 미리 검사하는 방법**으로 이 목적을 달성할 수 있다.
- 아래 계층에서 예외를 피할 수 없다면 **상위 계층에서 이 예외를 조용히 처리하여 문제를 API 호출자에까지 전파하지 않는 방법도 있다.**
    - 이 경우 발생한 예외는 `java.lang.logging`같은 적절한 로깅 기능을 활용하여 기록해두면 좋다.
    - 그렇게 해두면 클라이언트 코드와 사용자에게 문자를 전파하지 않으면서도 프로그래머가 로그를 분석해 추가 조치를 취할 수 있게 해준다.

## [아이템 74] 메서드가 던지는 모든 예외를 문서화하라

> 메서드가 던질 가능성이 있는 모든 예외를 문서화하라. 검사 예외든 비검사 예외든, 추상 메서드든 구체 메서드든 모두 마찬가지이다. 문사화에는 자바독의 `@throws` 태그를 사용하면 된다. **검사 예외만 메서드 선언의 throws 문에 일일이 선언하고, 비검사 예외는 메서드 선언에는 기입하지 말자.** 발생 가능한 예외를 문서로 남기지 않으면 다른 사람이 그 클래스나 인터페이스를 효과적으로 사용하기 어렵거나 심지어 불가능할 수도 있다.
> 

[Unckecked Exception과 Checked Exception](https://wildrabbit-yato.tistory.com/20)

[자바(Java)에서 예외(Exception)란 무엇인가?](https://mungto.tistory.com/419)

- 메서드가 던지는 예외는 그 메서드를 올바로 사용하는데 아주 중요한 정보이기 때문에 **각 메서드가 던지는 예외 하나하나를 문서화하는데 충분한 시간을 쏟아야한다.**
- 검사 예외는 항상 따로따로 선언하고, 각 예외가 발생하는 상황을 자바독의 `@throws` 태그를 사용하여 정확히 문서화하자.
    - 공통 상위 클래스 하나로 뭉뚱그려 선언하는 일은 삼가자.
    - 극단적인 예로 메서드가 `Exception`이나 `Throwable`을 던진다고 선언해서는 안된다.
        
        ```java
        public void examMethod() throws Exception {
        }
        ```
        
    - 메서드 사용자에게 각 예외에 대처할 수 있는 힌트를 주지 못할 뿐더러 같은 맥락에서 발생할 여지가 있는 다른 예외들까지 삼켜버릴 수 있어 API 사용성을 크게 떨어뜨린다.
    - 이 규칙에 유일한 예외가 있다면 바로 `main` 메서드이다.
        - `main`은 오직 JVM만이 호출하므로 `Exception`을 던지도록 선언해도 괜찮다.
- 자바 언어가 요구하는 것은 아니지만 **비검사 예외(런타임 오류)도 검사 예외(컴파일 오류)처럼 정성껏 문서화해두면 좋다.**
    - 비검사 예외는 일반적으로 프로그래밍 오류를 뜻하는데, 자신이 일으킬 수 있는 오류들이 무엇인지 알려주면 프로그래머는 자연스럽게 해당 오류가 나지 않도록 코딩하게 된다.
    - 잘 정비된 비검사 예외 문서는 사실상 그 메서드를 성공적으로 수행하기 위한 전제조건이 된다.
    - public 메서드라면 필요한 전제조건을 문서화해야 하며, 그 수단으로 가장 좋은 것이 바로 비검사 예외들을 문서화하는 것이다.
- 발생 가능한 비검사 예외를 문서로 남기는 일은 인터페이스 메서드에서 특히 중요하다.
    - 이 조건이 인터페이스의 일반 규약에 속하게 되어 그 인터페이슬 ㄹ 구현한 모든 구현체가 일관되게 동작하도록 해주기 때문이다.
- 메서드가 던질 수 있는 예외를 각각 `@throws` 태그로 문서화하되, **비검사 예외는 메서드 선언의 `throws` 목록에 넣지 말자.**
    
    ```java
    public static void main(String[] args) **throw NullPointerException** ...
    ```
    
    - 검사나 비검사냐에 따라 API 사용자가 해야할 일이 달라지므로 이 둘을 확실히 구분해주는 것이 좋다.
    - 자바독 유틸리티는 메서드 선언의 `throws` 절에 등장하고 메서드 주석의 `@throws` 태그에도 명시한 예외와 `@throws` 태그에만 명시한 예외를 시각적으로 구분해준다.
    
    → 프로그래머가 어느 것이 비검사 예외인지 바로 알 수 있다.
    
- 비검사 예외도 모두 문서화하라고 하지만 현실적으로 불가능할 때도 있다.
    - 예를 들어 다른 사람이 작성한 클래스를 사용하는 메서드가 있고, 발생 가능한 예외를 공들여 문서화했다고 가정하자.
    - 하지만 이후 외부 클래스가 새로운 비검사 예외를 던지게 수정된다면, 메서드는 문서에 언급되지 않은 새로운 비검사 예외를 전파하게 된다.
- 한 클래스에 정의된 많은 메서드가 같은 이유로 같은 예외를 던진다면 **그 예외를 각각의 메서드가 아닌 클래스 설명에 추가하는 방법도 있다.**
    
    ```java
    /**
     * <p> {@code NullPointerException} 지정한 요소에 null 이 들어오는 경우 발생합니다.</p> 
     */
    public class Exam {
    
        /**
         * @throws SQLException SQL 이 잘못된 경우
         * @throws ClassNotFoundException 지정한 경로에 클래스파일이 존재하지 않는경우.
         */
        public void examMethod() throws SQLException,ClassNotFoundException{
            Class.forName("asd");
            // TODO 무언가 했음.
        }
    
        public void examMethod2() throws IOException{
           //TODO 일하는 중
        }
    }
    ```
    
    - `NullPointerException`이 가장 흔한 사례이다.

## [아이템 75] 예외의 상세 메시지에 실패 관련 정보를 담으라

- 예외를 잡지 못해 프로그램이 실패하면 자바 시스템은 **그 예외의 스택 추적(stack trace) 정보를 자동으로 출력한다.**
    - 스택 추적은 예외 객체의 `toString` 메서드를 호출해 얻는 문자로, 보통은 **예외의 클래스 이름 뒤에 상세 메시지가 붙는 형태이다.**
        
        ![[https://github.com/Meet-Coder-Study/book-effective-java/blob/main/10장/75_예외의_상세_메세지에_실패_관련_정보를_담으라_김재준.md](https://github.com/Meet-Coder-Study/book-effective-java/blob/main/10%EC%9E%A5/75_%EC%98%88%EC%99%B8%EC%9D%98_%EC%83%81%EC%84%B8_%EB%A9%94%EC%84%B8%EC%A7%80%EC%97%90_%EC%8B%A4%ED%8C%A8_%EA%B4%80%EB%A0%A8_%EC%A0%95%EB%B3%B4%EB%A5%BC_%EB%8B%B4%EC%9C%BC%EB%9D%BC_%EA%B9%80%EC%9E%AC%EC%A4%80.md)](https://camo.githubusercontent.com/9029462de74216e57ab31264aaab671996c2cf4b265885c48e098042793000ce/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f3030386933736b4e67793167736a376f796a6d68716a3330686f3031773379722e6a7067)
        
        [https://github.com/Meet-Coder-Study/book-effective-java/blob/main/10장/75_예외의_상세_메세지에_실패_관련_정보를_담으라_김재준.md](https://github.com/Meet-Coder-Study/book-effective-java/blob/main/10%EC%9E%A5/75_%EC%98%88%EC%99%B8%EC%9D%98_%EC%83%81%EC%84%B8_%EB%A9%94%EC%84%B8%EC%A7%80%EC%97%90_%EC%8B%A4%ED%8C%A8_%EA%B4%80%EB%A0%A8_%EC%A0%95%EB%B3%B4%EB%A5%BC_%EB%8B%B4%EC%9C%BC%EB%9D%BC_%EA%B9%80%EC%9E%AC%EC%A4%80.md)
        
        - 이 정보가 실패 원인을 분석해야 하는 프로그래머 혹은 사이트 신뢰성 엔지니어(site reliability engineer, SRE)가 얻을 수 있는 유일한 정보인 경우가 많다.
    - 또한 그 실패를 재현하기 어렵다면 더 자세한 정보를 얻기가 어렵거나 불가능하다.
        - 따라서 예외의 `toString` 메서드에 **실패 원인에 관한 정보를 가능한 한 많이 담아 반환하는 일은 아주 중요하다.**
        - 사후 분석을 위해 **실패 순간의 상황을 정확히 포착해 예외의 상세 메시지에 담아야한다.**
            
            ![[https://github.com/Meet-Coder-Study/book-effective-java/blob/main/10장/75_예외의_상세_메세지에_실패_관련_정보를_담으라_김재준.md](https://github.com/Meet-Coder-Study/book-effective-java/blob/main/10%EC%9E%A5/75_%EC%98%88%EC%99%B8%EC%9D%98_%EC%83%81%EC%84%B8_%EB%A9%94%EC%84%B8%EC%A7%80%EC%97%90_%EC%8B%A4%ED%8C%A8_%EA%B4%80%EB%A0%A8_%EC%A0%95%EB%B3%B4%EB%A5%BC_%EB%8B%B4%EC%9C%BC%EB%9D%BC_%EA%B9%80%EC%9E%AC%EC%A4%80.md)](https://camo.githubusercontent.com/ec5d69ce52170a716a4297f439348a6e1e1ff56009c0cf8be0f761ac524bca8d/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f3030386933736b4e67793167736a383038686d64746a33307565303272676d392e6a7067)
            
            [https://github.com/Meet-Coder-Study/book-effective-java/blob/main/10장/75_예외의_상세_메세지에_실패_관련_정보를_담으라_김재준.md](https://github.com/Meet-Coder-Study/book-effective-java/blob/main/10%EC%9E%A5/75_%EC%98%88%EC%99%B8%EC%9D%98_%EC%83%81%EC%84%B8_%EB%A9%94%EC%84%B8%EC%A7%80%EC%97%90_%EC%8B%A4%ED%8C%A8_%EA%B4%80%EB%A0%A8_%EC%A0%95%EB%B3%B4%EB%A5%BC_%EB%8B%B4%EC%9C%BC%EB%9D%BC_%EA%B9%80%EC%9E%AC%EC%A4%80.md)
            
- 실패 순간을 포착하려면 발생한 예외에 관여된 모든 매개변수와 필드의 값을 실패 메시지에 담아야 한다.
    - 예를 들어 `IndexOutOfBoundsException`의 상세 메시지는 범위의 최솟값과 최댓값, 그리고 그 범위를 벗어났다는 인덱스의 값을 담아야 한다.

<aside>
✅ 보안과 관련된 정보는 주의해서 다뤄야 한다. 문제를 진단하고 해결하는 과정에서 스택 추적 정보를 많은 사람들이 볼 수 있으므로 상세 메시지에 비밀번호나 암호 키 같은 정보까지 담아서는 안 된다.

</aside>

- 예외 메시지를 상세하게 담아야하지만 장황할 필요는 없다.
    - stack trace에 예외가 발생한 파일 이름과 줄 번호가 기록되어 있기 때문이다.
- 예외의 상세 메시지와 최종 사용자에게 보여줄 오류 메시지를 혼동해서는 안 된다.
    - 최종 사용자에게는 친절한 안내 메세지, 예외 메시지는 담긴 내용이 중요하다.

## [아이템 76] 가능한 한 실패 원자적으로 만들라

- 작업 도중 예외가 발생해도 그 객체는 여전히 정상적으로 사용할 수 있는 상태라면 멋지지 않은가?
    - **호출된 메서드가 실패하더라도 해당 객체는 메서드 호출 전 상태를 유지해야 한다.**
    - 이러한 특성을 실패 원자적(failure-atomic)이라고 한다.
- 메서드를 실패 원자적으로 만드는 방법은 다양하다.
    - 가장 간단한 방법은 **불변 객체로 설계하는 것이다.**
    - 불변 객체는 태생적으로 실패 원자적이다.
        - 메서드가 실패하면 새로운 객체가 만들어지지는 않을 수 있으나 기존 객체가 불안정한 상태에 빠지는 일은 전혀 없다.
        - **불변 객체의 상태는 생성 시점에 고정되어 절대 변하지 않기 때문이다.**
- 가변 객체의 메서드를 실패 원자적으로 만드는 가장 흔한 방법은 **작업 수행에 앞서 매개변수의 유효성을 검사하는 것이다.**
    - 객체의 내부 상태를 변경하기 전에 잠재적 예외의 가능성 대부분을 걸러낼 수 있는 방법이다.
    
    ```java
    public Object pop() {
    	if (size == 0)
    		throw new EmptyStackException();
    	...
    }
    ```
    
- **실패할 가능성이 있는 모든 코드를 객체의 상태를 바꾸는 코드보다 앞에 배치**하는 방법도 있다.
    - 계산을 수행하기 전에 인수의 유효성을 검사할 수 없을 때 앞서의 방식에 덧붙여 쓸 수 있는 기법이다.
    - 상태가 바뀌기 전에 오류가 발생하여 상태 변경 코드가 실행되지 않는다.
- **객체의 임시 복사본에서 작업을 수행한 다음, 작업이 성공적으로 완료되면 원래 객체와 교체하는 방법**도 있다.
    - 데이터를 임시 자료구조에 저장해 작업하는 것이 더 빠를 때 적용하기 좋은 방식이다.
- 마지막 방법은 **작업 도중 발생하는 실패를 가로채는 복구 코드를 작성**하여 작업 전 상태로 되돌리는 방법이다.
    - 주로 디스크 기반의 내구성을 보장해야 하는 자료구조에 쓰이는데, 자주 쓰이는 방법은 아니다.
- 실패 원자성은 일반적으로 권장되는 덕목이지만 항상 달성할 수 있는 것은 아니다.
    - 예를 들어 두 쓰레드가 동기화 없이 같은 객체를 동시에 수정한다면 그 객체의 일관성이 깨질 수 있다.
        - 따라서 `ConcurrentModificationException`을 잡아냈다고 해서 그 객체가 여전히 쓸 수 있는 상태라고 가정해서는 안된다.
    - 한편 `Error`는 복구할 수 없으므로 `AssertionError`에 대해서는 실패 원자적으로 만들려는 시도조차 할 필요가 없다.
- 실패 원자적으로 만들 수 있더라도 항상 그렇게 해야 하는 것은 아니다.
    - 실패 원자성을 달성하기 위한 비용이나 복잡도가 아주 큰 연산도 있기 때문이다.
    - 그래도 문제가 무엇인지 알고 나면 실패 원자성을 공짜로 얻을 수 있는 경우가 더 많다.

## [아이템 77] 예외를 무시하지 말라

- API 설계자가 메서드 선언에 예외를 명시하는 까닭은 그 메서드를 사용할 때 적절한 조치를 취해달라고 말하는 것이다.
    
    ```java
    try {     // catch 블록을 비워두면 예외가 무시된다.
    	...
    } catch (SomeException e) {
    }
    ```
    
    - 예외는 문제 상황에 잘 대처하기 위해 존재하는데 `catch` 블록을 비워두면 예외가 존재할 이유가 없어진다.
- 물론 예외를 무시해야 할 때도 있다.
    - 예를 들어 `FileInputStream`을 닫을 때가 그렇다.
    - 입력 전용 스트림이므로 파일의 상태를 변경하지 않았으니 복구할 것이 없으며, 스트림을 닫는다는 것은 필요한 정보는 이미 다 읽었다는 것이니 중단할 이유도 없다.
- 예외를 무시하기로 했다면 `catch` 블록 안에 그렇게 결정한 이유를 주석으로 남기고 예외 변수의 이름도 `ignored`로 바꿔놓도록 하자.
    
    ```java
    Future<Integer> f = exec.submit(planarMap::chromaticNumber);
    int numColors = 4;
    
    try {
    	numColors = f.get(1L, TimeUnit.SECONDS);
    } catch (TimeoutException | ExecutionException ignored) {
    
    }
    ```

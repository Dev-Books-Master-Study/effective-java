## 42. 익명 클래스보다 람다를 사용하라

- Java에서 함수 타입을 표현하는 방법
    - 추상 메서드가 하나인 인터페이스 → 익명 클래스
- 익명 클래스는 코드가 길다는 단점 → Java는 함수형 프로그래밍에 부적합
- Java 8에 와서 추상 메서드가 하나인 인터페이스가 람다식에 사용됨
- **Before**

    ```java
    	Collections.sort(words, new Comparator<String>() {
                public int compare(String s1, String s2) {
                    return Integer.compare(s1.length(), s2.length());
                }
            });
    ```

- **After**

    ```java
    Collections.sort(words,
                    (s1, s2) -> Integer.compare(s1.length(), s2.length()));
        }
    ```

<br>

- 컴파일러가 알아서 매개변수 타입을 설정하지만 타입을 결정하지 못하면 개발자가 직접 명시
- 타입 추론 규칙은 너무 복잡해서 이해를 못함
- 컴파일러가 타입 추론을 못하면 `타입을 알 수 없다` 오류를 발생시킴
- 람다의 모든 매개변수 타입은 생략하는 것이 바람직

<br>

- 람다는 이름이 없고 문서화가 불가능
- 코드 자체로 동작이 명확히 설명이 안 되거나 코드 줄 수가 많다면 람다 사용을 지양
- 람다식은 1~3줄이 적절함
- 람다를 직렬화하는 것은 금지

<br>

## 43. 람다보다 메서드 참조를 사용하라

- 람다 사용 이유 → 익명 클래스보다 간결함
- 메서드 참조가 람다보다 더 간결함
- **람다**

    ```java
    map.merge(key, 1, (count, incr) -> count + incr);
    ```

- **메서드 참조**

    ```java
    map.merge(key, 1, Integer::sum);
    ```
<br>

- 람다가 메서드 참조보다 좋은 경우가 있음
- 람다가 길이는 더 길지만 메서드 참조보다 가독성과 유지보수가 용이함

<br>

- 람다가 할 수 없는 일 → 메서드 참조도 불가능
- 메서드 참조가 대체로 짧고 명확하지만 람다보다 복잡한 경우가 있음
- 메서드 참조를 지향하되 더 복잡한 경우 람다 사용

<br>

## 44. 표준 함수형 인터페이스를 사용하라

- 필요에 따라 함수형 인터페이스를 직접 구현할 수 있지만 대부분 `java.util.function` 패키지가 제공하는 표준 함수형 인터페이스로 해결할 수 있음
- 표준 함수형 인터페이스는 대부분 기본 타입만 지원
- 그렇다고 기본 함수형 인터페이스에 박싱된 기본 타입을 넣어 사용하면 안 됨
    - 계산량이 많으면 성능이 떨어짐
- 드물게 직접 함수형 인터페이스를 만들어 쓰는 편이 나은 경우도 있음
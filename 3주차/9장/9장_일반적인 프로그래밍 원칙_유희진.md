## [아이템 57] 지역변수의 범위를 최소화하라

- 지역 변수의 유효 범위를 최소로 줄이면 코드 가독성과 유지보수성이 높아지고 오류 가능성은 낮아진다.
- C와 같이 역사가 깊은 프로그래밍 언어 중에는 지역변수를 코드 블록의 첫 머리에 선언하는 경우가 많고, 이 방식을 여전히 따르는 프로그래머도 있다.
    - 그러나 자바에서는 문장을 선언할 수 있는 곳이면 어디서든 변수를 선언할 수 있다.
- 지역변수의 범위를 줄이는 가장 강력한 기법은 ‘**가장 처음 쓰일 때 선언하기**’다.
    - 사용하려면 멀었는데 미리 선언하면 코드가 어수선해져 가독성이 떨어진다.
    - 변수를 실제로 사용하는 시점에는 타입과 초깃값이 기억나지 않을 수도 있다.
- 지역 변수를 생각 없이 선언하다 보면 변수가 쓰이는 범위보다 너무 앞서 선언하거나 다 쓴 뒤에도 여전히 살아 있게 되기 쉽다.
    - 지역변수의 범위는 선언된 지점부터 그 지점을 포함한 블록이 끝날 때까지이므로, 실제 사용하는 블록 바깥에 선언된 변수는 그 블록이 끝난 뒤까지 살아 있게 된다.
    - 따라서 실수로 의도한 범위 앞 혹은 뒤에서 그 변수를 사용하면 끔찍한 결과로 이어질 수 있다.
- 거의 모든 지역 변수는 선언과 동시에 초기화해야 한다.
    - 초기화에 필요한 정보가 충분하지 않다면 충분해질 때까지 선언을 미뤄야한다.
    - `try-catch`문은 이 규칙에서 예외이다.
    - 변수를 초기화하는 표현식에서 검사 예외를 던질 가능성이 있다면 `try` 블록 안에서 초기화해야 하는데, 변수 값을 `try` 블록 바깥에도 사용할 가능성이 있다면 블록 바깥에 선언해야한다.
- 반복 변수의 값을 반복문이 종료된 뒤에도 써야하는 상황이 아니라면 while문보단 for문을 사용하는 것이 낫다.
    - 컬렉션을 순회할 때 권장하는 관용구(향상된 for문)
        
        ```java
        for (Element e : c) {
        	// ...
        }
        ```
        
    - 반복자를 사용하는 경우 전통적인 `for`문을 사용한다.
        
        ```java
        for (Iterator<Element> i = c.iterator(); i.hasNext();) {
        	Element e = i.next();
        }
        ```
        
- 지역 변수 범위를 최소화하는 마지막 방법은 메서드를 작게 유지하고 한 가지 기능에 집중하는 것이다.

## [아이템 58] 전통적인 for문 보다는 for-each문을 사용하라

> 전통적인 `for`문과 비교했을 때 `for-each`문은 명료하고, 유연하고 버그를 예방해준다. 성능 저하도 없다.
> 

```java
for (int i = 0; i < a.length; i++) {
	...
}
```

- 반복자와 인덱스는 코드를 지저분하게 하며, 우리에게 진짜 필요한 것은 원소들 뿐이다.
- `for-each`를 사용하면 모두 해결된다.
    
    ```java
    for (Element e : c) {
    	// ...
    }
    ```
    
    - 반복자와 인덱스를 사용하지 않으니 코드가 깔끔해지고 오류가 나지도 않는다.

### for-each를 사용할 수 없는 상황

1. 파괴적인 필터링(destructive filtering)
    - 컬렉션을 순회하면서 선택된 원소를 제거해야 한다면 반복자의 `remove` 메서드를 호출해야 한다.
    - java 8 부터는 Collection의 `removeIf`를 사용해 컬렉션을 명시적으로 순회하는 일을 피할 수 있다.
2. 변형(transforming)
    - 리스트나 배열을 순회하면서 그 원소의 값 일부 혹은 전체를 교체해야 한다면 리스트의 반복자나 배열의 인덱스를 사용해야 한다. ex) swap
3. 병렬 반복(parallel iteration)
    - 여러 컬렉션을 병렬로 순회해야 한다면 각각의 반복자와 인덱스 변수를 사용해 엄격하고 명시적으로 제어해야 한다.

## [아이템 59] 라이브러리를 익히고 사용하라

> 바퀴를 다시 발명하지 말자. 아주 특별한 나만의 기능이 아니라면 누군가 이미 라이브러리 형태로 구현해놓았을 가능성이 크다. 그런 라이브러리가 있다면 쓰면 되고, 있는지 잘 모르겠다면 찾아봐라. 일반적으로 라이브러리 코드는 우리가 직접 작성한 것보다 품질이 좋고, 점차 개선될 가능성이 크다.
> 

```java
static Random rnd = new Random();

static int random(int n) {
	return Math.abs(rnd.nextInt()) % n;
}
```

- 위 코드는 무작위 정수 하나를 생성한다.
- 아래와 같은 문제점이 존재한다.
    1. n이 그리 크지 않은 2의 제곱수라면 얼마 지나지 않아 같은 수열이 반복된다.
    2. n이 2의 제곱수가 아니라면 몇몇 숫자가 평균적으로 더 자주 반환된다.
        1. n값이 크면 이 현상은 더욱 두드러진다.
    3. 지정된 범위의 바깥 수가 종종 튀어나올 수 있다.
        1. `rnd.nextInt()`가 반환한 값을 `Math.abs`를 이용해 음수가 아닌 정수로 매핑하기 때문이다.

### 표준 라이브러리 장점

- 표준 라이브러리를 사용하면 그 코드를 작성한 전문가의 지식과 우리보다 앞서 사용한 다른 프로그래머들의 경험을 활용할 수 있다.
    - 자바 7부터는 `Random`을 더 이상 사용하지 않는 것이 좋다.
        - `ThreadLocalRandom`을 사용하면 대부분 잘 작동한다.
        - `Random`보다 빠르고 고품질의 무작위 수를 생성한다.
- 표준 라이브러리를 쓰는 두번째 이점은 핵심적인 일과 크게 관련 없는 문제를 해결하느라 시간을 허비하지 않아도 된다는 것이다.
    - 프로그래머는 하부 공사를 하기 보다는 애플리케이션 기능 개발에 집중하고 싶어한다.
- 세번째 이점은 따로 노력하지 않아도 성능이 지속해서 개선된다는 점이다.
    - 표준 라이브러리 제작자들이 더 나은 방법을 모색하기 때문이다.
- 네번째 이점은 기능이 점점 많아진다는 것이다.
    - 라이브러리에 부족한 부분이 있다면 개발자 커뮤니티에서 이야기가 나오고 논의된 후 다음 리리스에 해당 기능이 추가되곤 한다.
- 마지막으로는 우리가 작성한 코드가 많은 사람들에게 낯익은 코드가 된다는 것이다.

## [아이템 60] 정확한 답이 필요하다면 float과 double은 피하라

> 정확한 답이 필요한 계산에는 `float`나 `double`을 피하라. 소수점 추적은 시스템에 맡기고 코딩 시의 불편함이나 성능 저하를 신경쓰지 않겠다면 `BigDecimal`을 사용하라. `BigDecimal`이 제공하는 여덟가지 반올림 모드를 이용하여 반올림을 완벽히 제어할 수 있다. 반면에 성능이 중요하고 소수점을 직접 추적할 수 있고 숫자가 너무 크지 않다면 `int`나 `long`을 사용하라
> 
- `float`과 `double` 타입은 과학과 공학 계산용으로 설계되었다.
    - 이진 부동소수점 연산에 쓰이며, 넓은 범위의 수를 빠르게 정밀한 근사치로 계산하도록 세심하게 설계되었다.
    - 따라서 정확한 결과가 필요할 때는 사용하면 안 된다.
- `float`과 `double` 타입은 특히 금융 관련 계산과는 맞지 않는다.
    - 0.1 혹은 10의 음의 거듭 제곱수(10^-1, 10^-2) 등을 표현할 수 없기 때문이다.
- 예를 들어 주머니에 1.03 달러가 있는데 그 중 42센트를 썼다고 가정해보자.
    
    ```java
    1.03 - 0.42  // 0.6100000000000000001
    ```
    
    - 남은 돈을 계산하기 위해 위와 같이 코드를 작성하면, 결과는 정확하지 않다.
- 결과값을 출력하기 전에 반올림하면 해결되리라 생각할 수도 있지만, 반올림을 해도 틀린 답이 나올 수 있다.
    - 예를 들어 주머니에 1달러가 있고, 선반에 10센트, 20센트, 30센트 … 1달러짜리의 맛있는 사탕이 놓여있다고 가정해보자.
    - 10센트짜리부터 하나씩 살 수 있을 때까지 산다고 가정해보자.
    
    ```java
    double funds = 1.00;
    int itemsBought = 0;
    for (double price = 0.10; funds >= price; price += 0.10) {
    	funds -= price;
    	itemsBought++;
    }
    ```
    
    - 프로그램을 실행하면 사탕 3개를 구입한 후 잔돈은 0.39999999999999999999달러이다.
- 금융 계산에서는 `BigDecimal`, `int`, `long`을 사용해야 한다. → 실제 신한은행 면접 질문이었음
- `BigDecimal`에는 단점이 두 가지가 있다.
    1. 기본타입보다 쓰기가 불편하다.
    2. 느리다.
- `BigDecimal` 대신 `int`, `long`을 사용할 경우 다룰 수 있는 값의 크기가 제한되고 소수점을 직접 관리해야 한다.

## [아이템 61] 박싱된 타입보다는 기본 타입을 사용하라

> 기본 타입과 박싱된 기본 타입 중 하나를 선택해야 한다면 **가능한 기본 타입을 사용하라.** 기본 타입은 간단하고 빠르다. 박싱된 기본 타입을 써야한다면 주의를 기울이자. 오토박싱이 박싱된 기본 타입을 사용할 때의 번거로움을 줄여주지만, 그 위험까지 없애주지는 않는다. 두 박싱된 기본 타입을 `==` 연산자로 비교한다면 식별성 비교가 이루어지는데, 이는 우리가 원한게 아닐 가능성이 크다. 같은 연산에서 기본 타입과 박싱된 기본 타입을 혼용하면 언박싱이 이루어지며, 이 과정에서 NullPointerException이 발생할 수 있다.
> 

<aside>
📝 여기서는 기본 타입을 사용하는 것이 좋다고 하지만, Spring에서 requestDto를 사용할 땐 Reference Type이 좋습니다! [https://medium.com/sjk5766/spring-boot-request의-boolean-타입-validation-중-발생한-소소한-문제-1a6842764ec5](https://medium.com/sjk5766/spring-boot-request%EC%9D%98-boolean-%ED%83%80%EC%9E%85-validation-%EC%A4%91-%EB%B0%9C%EC%83%9D%ED%95%9C-%EC%86%8C%EC%86%8C%ED%95%9C-%EB%AC%B8%EC%A0%9C-1a6842764ec5)

</aside>

- 오토박싱과 오토 언박싱 덕분에 두 타입을 크게 구분하지 않고 사용할 수는 있지만, 그렇다고 차이가 사라지는 것은 아니다.
- 기본타입과 박싱 타입의 주된 차이는 다음과 같다.
    1. 기본 타입은 값만 가지고 있으나, 박싱된 기본 타입은 값에 더해 식별성(identity)이란 속성을 가진다.
        - 박싱된 기본 타입의 두 인스턴스는 값이 같아도 서로 다르다고 식별될 수 있다.
    2. 기본 타입의 값은 언제나 유효하지만, 박싱 타입은 `null`을 가질 수 있다.
    3. 기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용면에서 더 효율적이다.
- 아래 코드는 Integer를 오름차순으로 정렬하는 비교자다.
    
    ```java
    Comprator<Integer> naturalOrder = (i, j) -> (i < j) ? -1 : (i == j ? 0 : 1);
    ```
    
    - 위 코드에서 결함을 확인하고 싶다면 `naturalOrder.compare(new Integer(42), new Integer(42))`의 값을 출력하는 것이 좋다.
        - 두 인스턴스의 값이 42로 같으므로 0을 출력해야한다고 하지만, 실제로는 1을 출력한다.
    - `naturalOrder`의 첫 번째 검사`(i < j)`는 잘 작동한다.
        - 여기서 i와 j가 참조하는 오토박싱된 `Integer` 인스턴스는 기본 타입 값으로 변환된다.
    - 그 후 `(i == j)`를 실행하는데, **이 검사에서는 두 객체의 참조의 식별성을 검사**한다.
    - 즉, 박싱된 기본 타입에 `==` 연산자를 생각하면 원하는 결과를 얻을 수 없다.
- 이러한 문제를 수정하려면 지역변수 2개를 두어 각 박싱된 매개변수 값을 기본 타입으로 저장한 후 비교해야한다.
    
    ```java
    Comprator<Integer> naturalOrder = (iBoxed, jBoxed) -> {
    	int i = iBoxed;
    	int j = jBoxed;
    	return (i < j) ? -1 : (i == j ? 0 : 1);
    }
    ```
    
- 아래 코드는 박싱과 언박싱이 반복적으로 일어나 성능이 느려진다.
    
    ```java
    Long sum = 0L;
    for (long i = 0; i <= Integer.MAX_VALUE; i++) {
    	sum += i;
    }
    ```
    
- 박싱 타입은 아래와 같은 경우에 쓰면 적합하다.
    1. 컬렉션의 원소, 키 값
    2. 리플렉션을 통해 메서드를 호출할 때

## [아이템 62] 다른 타입이 적절하다면 문자열 사용을 피하라

> 더 적합한 데이터 타입이 있거나 새로 작성할 수 있다면 문자열을 쓰고 싶은 유혹을 뿌리쳐라. 문자열은 잘못 사용하면 번거롭고, 덜 유연하고, 느리고, 오류 가능성도 크다.
> 
- 문자열은 다른 값 타입을 대신하기에 적합하지 않다.
    - 받은 데이터가 수치형이라면 `int`, `float`, `BigInteger` 등 적당한 수치 타입으로 변환해야 한다.
    - ‘예/아니오’ 질문의 답이라면 적절한 열거 타입 혹은 `boolean`을 사용하는 것이 좋다.
- 문자열은 열거 타입을 대신하기에 적합하지 않다.
    - 상수를 열거할 땐 문자열보다는 열거타입이 월등히 낫다.
- 문자열은 혼합 타입을 대신하기에 적합하지 않다.
    - 여러 요소가 혼합된 데이터를 하나의 문자열로 표현하는 것은 대체로 좋지 않은 생각이다.
        
        ```java
        String compoundKey = className + "#" + i.next();
        ```
        
        - 각 요소를 개별로 접근하려면 문자열을 파싱해야 해서 느리고, 귀찮고, 오류 가능성도 커진다.
        - 전용 클래스를 새로 만드는 편이 낫다.
- 문자열은 권한을 표현하기에 적합하지 않다.

## [아이템 63] 문자열 연결은 느리니 주의하라

[[JAVA] 문자열 연결 처리 속도 높이기](https://data-traveler.tistory.com/22)

> 성능에 신경써야 한다면 많은 문자열을 연결할 때는 문자열 연결 연산자를 피하라. 대신 `StringBuilder`의 `append` 메서드를 사용하라.
> 
- 문자열 연결 연산자 `+` 는 문자열 n개를 잇는 시간이 n^2에 비례한다.
- 문자열은 불변이므로, 두 문자열을 연결할 경우 양쪽의 내용을 모두 복사하기 때문에 성능 저하는 피할 수 없다.
- 대신 `StringBuilder`, `StringBuffer`를 사용하라.

## [아이템 64] 객체는 인터페이스를 사용해 참조하라

> 적합한 인터페이스가 없다면 클래스의 계층 구조 중 필요한 기능을 만족하는 가장 덜 구체적인 상위의 클래스를 타입으로 사용하라.
> 
- 적합한 인터페이스만 있다면 매개변수 뿐만 아니라 반환값, 변수, 필드를 전부 인터페이스 타입으로 선언하라.
- 객체의 실제 클래스를 사용해야 할 상황은 오직 생성자로 생성할 때 뿐이다.

```java
// good
Set<Son> sonSet = new LinkedHashSet<>();

// bad
LinkedHashSet<Son> sonSet = new LinkedHashSet<>();

// 교체
Set<Son> sonSet = new HashSet<>();
```

- 인터페이스를 타입으로 사용하는 습관을 길러두면 프로그램이 훨씬 유연해진다.
    - 추후 구현 클래스를 교체하고자 한다면 그저 새 클래스의 생성자 (혹은 다른 정적 팩터리)를 호출해주기만 하면 된다.
- 주의할 점으로는 원래의 클래스가 인터페이스의 일반 규약 이외의 특별한 기능을 제공하며, 주변 코드가 이 기능에 기대어 동작한다면 새로운 클래스도 반드시 같은 기능을 제공해야 한다.
    - 예를 들어 첫번째 선언한 `LinkedHashSet`은 순서 정책을 가정하고 동작하는 상황에서 이를 `HashSet`으로 바꾸면 문제가 될 수 있다.
- 구현타입을 바꾸는 이유는 원래 것보다 성능이 좋거나 멋진 신기능을 제공하기 때문일 수 있다.
    - 예를 들어 `HashSet`을 참조하던 변수를 `EnumMap`으로 바꾸면 속도가 빨라지고 순회 순서도 키의 순서와 같아진다.
    - 단, `EnumMap`은 키가 열거 타입일 때만 사용할 수 있다.
- 선언 타입과 구현 타입을 동시에 바꿀 수 있으니 변수를 구현 타입으로 선언해도 괜찮을거라 생각할 수도 있다.
    - 그러나 자칫하면 프로그램이 컴파일되지 않는다.
    - 예를 들어 클라이언트에서 기존 타입에만 제공하는 메서드를 사용했거나, 기존타입을 사용해야 하는 다른 메서드에 그 인스턴스를 넘기면 컴파일 되지 않는다.
    - 변수를 인터페이스 타입으로 선언하면 이러한 일이 발생하지 않는다.

### 인터페이스 대신 클래스 타입을 써도 되는 경우

- `String`, `BigInteger`같은 값 클래스처럼 적합한 인터페이스가 없다면 당연히 클래스로 참조해야한다.
    - 값 클래스를 여러 가지로 구현할 수 있다고 생각하고 설계하는 일은 별로 없다.
    - 따라서 `final`인 경우가 많고, 상응하는 인터페이스가 별도로 존재하는 경우가 드물다.
    - 이러한 값 클래스는 매개변수, 변수, 필드, 반환 타입으로 사용해도 무방하다.
- 적합한 인터페이스가 없는 두 번째 부류는 클래스 기반으로 작성된 프레임워크가 제공하는 객체들이다.
    - 이러한 경우라도 특정 구현 클래스보다는 추상 클래스인 기반 클래스를 사용해 참조하는 것이 좋다.
    - OutputStream등 [java.io](http://java.io) 패키지의 여러 클래스가 이 부류에 속한다.
        
       <img width="530" alt="스크린샷 2023-10-29 오후 10 36 14" src="https://github.com/yu-heejin/effective-java/assets/96467030/04f07e62-17cd-4e7a-bf9b-0a7c0deb3cf1">

        
- 적합한 인터페이스가 없는 마지막 부류는 인터페이스에는 없는 특별한 메서드를 제공하는 클래스들이다.
    - 예를 들어 `PriorityQueue`는 `Queue` 인터페이스에는 없는 `comparator` 메서드를 제공한다.
    - **클래스 타입을 직접 사용하는 경우는 이런 추가 메서드를 꼭 사용해야 하는 경우로 최소화** 해야하며, 남발하지 말아야한다.

## [아이템 65] 리플렉션보다는 인터페이스를 사용하라

> 리플렉션은 복잡한 특수 시스템을 개발할 때 필요한 강력한 기능이지만 단점도 많다. **컴파일 타임에는 알 수 없는 클래스를 사용하는 프로그램을 작성한다면 리플렉션을 사용해야할 것이다.** 단 되도록 객체 생성에만 사용하고, 생성한 객체를 이용할 땐 적절한 인터페이스나 컴파일 타임에 알 수 있는 상위 클래스로 형변환해 사용해야 한다.
> 
- 리플렉션 기능(`java.lang.reflect`)을 이용하면 프로그램에서 임의의 클래스에 접근할 수 있다.
- `Class` 객체가 주어지면 그 클래스의 생성자, 메서드, 필드에 해당하는 `Constructor`, `Method`, `Field` 인스턴스를 가져올 수 있고, 이어서 이 인스턴스들로는 그 클래스의 멤버 이름, 필드 타입, 메서드 시그니처 등을 가져올 수 있다.
- 나아가 `Constructor`, `Method`, `Field` 인스턴스를 통해 각각에 연결된 실제 생성자, 메서드 필드를 조작할 수도 있다.
    - 이 인스턴스들을 통해 해당 클래스의 인스턴스를 생성하거나, 메서드를 호출하거나, 필드에 접근할 수 있다는 의미이다.
    - 예를 들어 Method.invoke는 어떤 클래스의 어떤 객체가 가진 어떤 메서드라도 호출할 수 있게 해준다.

<aside>
✅ 리플렉션은 구체적인 클래스 타입을 알지 못하더라도 그 클래스의 메서드, 타입, 변수들에 접근할 수 있도록 해주는 자바 API를 말하며, **컴파일 시간이 아닌 실행 시간에 동적으로 특정 클래스의 정보를 추출할 수 있는 프로그래밍 기법**이라 할 수 있다. (https://jeongkyun-it.tistory.com/225)

</aside>

- 리플렉션을 이용하면 컴파일 당시 존재하지 않던 클래스도 이용할 수 있으나 단점이 존재한다.
    1. 컴파일 타임 타입 검사가 주는 이점을 누릴 수 없다.
        - 만약 프로그램이 리플렉션을 사용하여 존재하지 않는 혹은 접근할 수 없는 메서드를 호출하려고 시도한다면 런타임 오류가 발생한다.
    2. 리플렉션을 이용하면 코드가 지저분해지고 장황해진다.
    3. 성능이 떨어진다.
        - 리플렉션을 통한 메서드 호출은 일반 메서드 호출보다 훨씬 느리다.
- 리플렉션은 아주 제한된 형태로만 사용해야 그 단점을 피하고 이점만 취할 수 있다.
    - 컴파일 타임에 이용할 수 없는 클래스들을 사용해야만 하는 프로그램은 **비록 컴파일 타임이라도 적절한 인터페이스나 상위 클래스를 이용할 수는 있을 것이다.**
        - 이런 경우라면 리플렉션은 인스턴스 생성에만 사용하고, 만들어진 인스턴스는 인터페이스나 상위 클래스로 참조해 사용하자.
- 리플렉션은 런타임에 존재하지 않을 수도 있는 클래스, 메서드, 필드와의 의존성을 관리할 때 적합하다.
    - 이 기법은 버전이 여러개 존재하는 외부 패키지를 다룰 때 유용하다.
    - 가동할 수 있는 최소한의 환경, 즉 주로 가장 오래된 버전만을 지원하도록 컴파일한 후, 이후 버전의 클래스와 메서드 등은 리플렉션으로 접근하는 방식이다.
    - 이렇게 하려면 접근하려는 새로운 클래스나 메서드가 런타임에 존재하지 않을 수 있다는 사실을 감안해야 하며, 같은 목적을 이룰 수 있는 대체 수단을 이용하거나 기능을 줄여 동작하는 등의 적절한 조치를 취해야한다.

## [아이템 66] 네이티브 메서드는 신중히 사용하라

> 네이티브 메서드를 사용하려거든 한 번 더 생각하라. 네이티브 메서드가 성능을 개선해주는 일은 많지 않다. 저수준 자원이나 네이티브 라이브러리를 사용해야만 해서 어쩔 수 없더라도 네이티브 코드는 최소한만 사용하고 철저히 테스트하라. 네이티브 코드 안에 숨은 단 하나의 버그가 우리의 애플리케이션 전체를 훼손할 수도 있다.
> 

[JAVA Native Method (JNI)](https://roughexistence.tistory.com/81)

- 자바 네이티브 인터페이스(Java Native Interface, JNI)는 자바 프로그램이 네이티브 메서드를 호출하는 기술이다.
    - 여기서 네이티브 메서드란 C나 C++같은 네이티브 프로그래밍 언어로 작성한 메서드를 말한다.
- 전통적으로 네이티브 메서드의 주요 쓰임은 다음과 같다.
    1. 레지스트리 같은 플랫폼 특화 기능을 사용한다.
    2. 네이티브 코드로 작성된 기존 라이브러리를 사용한다.
        1. 레거시 데이터를 사용하는 레거시 라이브러리가 그 예다.
    3. 성능 개선을 목적으로 성능에 결정적인 영향을 주는 영역만 따로 네이티브 언어로 작성한다.
- 플랫폼 특화 기능을 활용하려면 네이티브 메서드를 사용하는 것이 좋다.(자바는 플랫폼 독립적)
    - 그러나 자바가 성숙해가면서 OS같은 하부플랫폼의 기능을 점차 흡수하고 있어 네이티브 메서드를 사용할 필요가 계속 줄어들고 있다.
    - 예를 들어 자바 9는 새로 process API를 추가해 OS 프로세스에 접근하는 길을 열어주었다.
- 성능 개선 목적으로 네이티브 메서드를 사용하는 것은 권장하지 않는다.
    - JVM도 시간이 지날수록 엄청난 속도로 발전해왔다.

### 네이티브 메서드의 심각한 단점

1. 네이티브 언어가 안전하지 않으므로 네이티브 메서드를 사용하는 애플리케이션도 메모리 훼손 오류로부터 안전하지 않다.
    1. 네이티브 언어는 자바보다 플랫폼을 많이 타서 이식성도 낮고, 디버깅도 어렵고, 속도가 오히려 느려질 수 있다.
2. 가비지 컬렉터가 네이티브 메모리는 자동 회수하지 못하고 추적조차 할 수 없다.
3. 자바 코드와 네이티브 코드의 경계를 넘나들 때마다 비용도 추가된다.
4. 네이티브 메서드와 자바 코드 사이의 접착 코드를 작성해야하는데, 귀찮기도 하고 가독성도 떨어진다.

## [아이템 67] 최적화는 신중히 하라

> 빠른 프로그램을 작성하려 안달하지 말자. **좋은 프로그램을 작성하다 보면 성능은 따라오게 마련이다.** 하지만 **시스템을 설계할 때, 특히 API, 네트워크 프로토콜, 영구 저장용 데이터 포멧을 설계할 때는 성능을 염두에 두어야한다.** 시스템 구현을 완료했다면 이제 성능을 측정해보라. 충분히 빠르면 그것으로 끝이다. 그렇지 않다면 프로파일러를 사용해 문제의 원인이 되는 지점을 찾아 최적화를 수행하라. 가장 먼저 어떤 알고리즘을 사용했는지를 살펴보자. 알고리즘을 잘못 골랐다면 다른 저수준 최적화는 아무리 해봐야 소용이 없다. 만족할 때까지 이 과정을 반복하고, 모든 변경 후에는 성능을 측정하라.
> 

[미국가서 중국어 공부하지 않기](https://jojoldu.tistory.com/733)

<aside>
📝 맹목적인 어리석음을 포함해 그 어떤 핑계보다 효율성이라는 이름 아래 행해진 컴퓨팅 죄악이 더 많다. - 윌리엄 울프

</aside>

<aside>
📝 (전체의 97% 정도인) 자그마한 효율성은 모두 잊자. 섣부른 최적화가 만악의 근원이다. - 도널드 크누스

</aside>

<aside>
📝 최적화를 할 때는 다음 두 규칙을 따르라. 1. 하지마라, 2. (전문가 한정) 아직 하지마라. 다시 말해 완전히 명백하고 최적화되지 않은 해법을 찾을 때까지는 하지 마라. - M.A. 잭슨

</aside>

- 최적화는 좋은 결과보다는 해로운 결과로 이어지기 쉽고, 섣불리 진행하면 특히 그렇다.
- 성능 때문에 견고한 구조를 희생하지마라. 빠른 프로그램보다는 좋은 프로그램을 작성하라.
- 좋은 프로그램이지만 원하는 성능이 나오지 않는다면 그 아키텍처 자체가 최적화할 수 있는 길을 안내해줄 것이다.
- 좋은 프로그램은 정보 은닉 원칙을 따르므로 개별 구성 요소의 내부를 독립적으로 설계할 수 있다.
    - 따라서 시스템의 나머지에 영향을 주지 않고도 각 요소를 다시 설계할 수 있다.
- 프로그램을 완성할 때까지 성능 문제를 무시하라는 뜻이 아니다.
    - 구현상의 문제는 나중에 최적화해 해결할 수 있지만, 아키텍처의 결함이 성능을 제한하는 상황이라면 시스템 전체를 다시 작성하지 않고는 해결하기 불가능할 수 있다.
    - 완성된 설계의 기본 틀을 변경하려다 보면 유지보수하거나 개선하기 어려운 꼬인 구조의 시스템이 만들어지기 쉽기 때문이다.
    - 따라서 설계 단계에서 성능을 반드시 염두에 두어야한다.
- 성능을 제한하는 설계를 피하라.
    - 완성 후 변경하기가 가장 어려운 설계 요소는 바로 컴포넌트끼리, 혹은 외부 시스템과의 소통 방식이다.
        - API, 네트워크 프로토콜, 영구 저장용 데이터 포맷 등이 대표적이다.
    - 이런 설계 요소들은 완성 후에는 변경하기 어렵거나 불가능할 수 있으며, 동시에 시스템 성능을 심각하게 제한할 수 있다.
- API를 설계할 때 성능에 주는 영향을 고려하라
    - `public` 타입을 가변으로 만들면 불필요한 방어적 복사를 수없이 유발할 수 있다.
    - 비슷하게 컴포지션으로 해결할 수 있음에도 상속 방식으로 설계한 public class는 상위 클래스에 영원히 종속되며 그 성능 제약까지도 물려받게 된다.
    - 인터페이스도 있는데 굳이 구현 타입을 사용하는 것 역시 좋지 않다.
        - 특정 구현체에 종속되게 하며, 나중에 더 빠른 구현체가 나오더라도 이용하지 못하게 된다.
- 잘 설계된 API는 성능도 좋은게 보통이다.
    - 따라서 성능을 위해 API를 왜곡하는 것은 매우 안 좋은 생각이다.
- 신중하게 설계하여 깨끗하고 명확하고 멋진 구조를 갖춘 프로그램을 완성한 다음에야 최적화를 고려해볼 차례가 된다.

### “각각의 최적화 시도 전후로 성능을 측정하라”

- 시도한 최적화 기법이 성능을 눈에 띄게 높이지 못하는 경우가 많고, 심지어 더 나빠지게 할 수도 있다.
- 주 원인은 우리의 프로그램에서 시간을 잡아먹는 부분을 추측하기 어렵기 때문이다.
- 시간낭비가 될 수 있으며 비효율적이다.
- 최적화를 할 때 **프로파일링 도구(profiling tool)를 사용하면 최적화 노력을 어디에 집중해야 할지 찾는데 도움을 준다.**

## [아이템 68] 일반적으로 통용되는 명명 규칙을 따르라

> 표준 명명 규칙을 체화하여 자연스럽게 베어 나오도록 하자. 철자 규칙은 직관적이라 모호한 부분이 적은데 반해, 문법 규칙은 더 복잡하고 느슨하다. 자바 언어 명세의 말을 인용하자면 “오랫동안 따라온 규칙과 충돌한다면 그 규칙을 맹종해서는 안된다.”
> 
- 자바의 명명 규칙은 크게 철자와 문법 두 범주로 나뉜다.

### 철자 규칙

- 패키지와 모듈 이름은 각 요소를 점으로 구분하여 계층적으로 짓는다.
    - 요소들은 모두 소문자 알파벳 혹은 드물게 숫자로 이루어진다.
    - 조직 밖에서도 사용될 패키지라면 조직의 인터넷 도메인 이름을 역순으로 사용한다.
        
        ```java
        edu.cmu, com.google, org.eff...
        ```
        
    - 예외적으로 표준 라이브러리와 선택적 패키지들은 각각 java와 javax로 시작한다.
        
        ```java
        java.util.Objects, javax.persistence.*...
        ```
        
- 패키지 이름의 나머지는 해당 패키지를 설명하는 하나 이상의 요소로 이루어진다.
    - 각 요소는 일반적으로 8자 이하의 짧은 단어로 한다.
    - utilities보다는 util처럼 의미가 통하는 약어를 추천한다.
    - 여러 단어로 구성된 이름이라면 awt처럼 각 단어의 첫 글자만 따서 써도 좋다.
    - 요소의 이름은 보통 한 단어 혹은 약어로 이루어진다.
- 인터넷 도메인 이름 뒤에 요소 하나만 붙인 패키지가 많지만, 많은 기능을 제공하는 경우엔 계층을 나눠 더 많은 요소로 구성해도 좋다.
    - 예를 들어 `java.util`은 `java.util.conurrent.atomic`과 같이 그 밑에 수많은 패키지를 가지고 있다.
    - 이처럼 하부의 패키지를 하위 패키지(subpackage)라 부른다.
- 클래스와 인터페이스 이름은 하나 이상의 단어로 이루어지며, 각 단어는 대문자로 시작한다. (스네이크 케이스)
    - 첫글자만 딴 약자나 max, min처럼 통용되는 줄임말을 제외하고는 단어를 줄여쓰지 않는다.
    - 약자는 일반적으로 첫 글자만 대문자로 한다. ex) HttpUrl
- 메서드와 필드 이름은 첫글자를 소문자로 쓴다는 점만 빼면 클래스 명명 규칙과 같다. (카멜 케이스)
    - 단 상수는 예외이며, 상수 필드를 구성하는 단어는 모두 대문자로 쓰고 단어 사이는 밑줄로 구분한다.
- 타입 매개변수 이름은 보통 한 문자로 표현한다.
    - T: 임의의 타입
    - E: 컬렉션 원소의 타입
    - K: 맵의 키, V: 맵의 값
    - X: 예외
    - R: 메서드의 반환

### 문법 규칙

- 객체를 생성할 수 있는 클래스(열거 타입 포함)의 이름은 보통 단수 명사나 명사구를 사용한다.
    - Thread, PriorityQueue, ChessPice 등
- 객체를 생성할 수 없는 클래스의 이름은 보통 목수형 명사로 짓는다.
    - Collectors, Collections 등
- 인터페이스 이름은 클래스와 똑같이 짓거나 able, ible로 끝나는 형용사로 짓는다.
    - Runnable, Iterable 등
- 어노테이션은 워낙 다양하게 활용되어 지배적인 규칙 없이 명사, 동사, 전치사, 형용사가 두루 쓰인다.
    - BindingAnnotation, Inject, ImplementedBy, Singleton 등
- 어떤 동작을 수행하는 메서드의 이름은 동사나 동사구로 짓는다.
- `boolean` 값을 반환하는 메서드라면 보통 is, has로 시작한다.
- 반환 타입이 `boolean`이 아니거나 해당 인스턴스의 속성을 반환하는 메서드의 이름은 보통 명사, 명사구, get으로 시작하는 동사구로 짓는다.
    - size, hashCode, getTime

### 특별한 메서드 이름

- 객체의 타입을 바꿔서, 다른 타입의 또 다른 객체를 반환하는 인스턴스 메서드의 이름은 보통 toType 형태로 짓는다.
    - toString, toArray 등
- 객체의 내용을 다른 뷰로 보여주는 메서드의 이름은 asType 형태로 짓는다.
    - asList 등
- 객체의 값을 기본 타입 값으로 반환하는 메서드의 이름은 보통 typeValue 형태로 짓는다.
    - intValue 등
- 정적 팩터리의 이름은 다양하지만 from, of, valueOf, instance, getInstance, newInstance, getType, newType을 흔히 사용한다.
